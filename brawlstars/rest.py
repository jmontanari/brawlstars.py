# coding: utf-8

"""
    Brawl Stars API

    Brawl Stars API

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501
import asyncio
import io
import json
import logging
import re
import ssl
from base64 import b64decode
from datetime import datetime
from itertools import cycle
from typing import Optional, Union

import aiohttp
import aiohttp_retry

from brawlstars.exceptions import ApiException, ApiValueError

RESTResponseType = aiohttp.ClientResponse

ALLOW_RETRY_METHODS = frozenset({'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PUT', 'TRACE'})

LOG = logging.getLogger(__name__)


class RESTResponse(io.IOBase):

    def __init__(self, resp) -> None:
        self.response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = None

    async def read(self):
        if self.data is None:
            self.data = await self.response.read()
        return self.data

    def getheaders(self):
        """Returns a CIMultiDictProxy of the response headers."""
        return self.response.headers

    def getheader(self, name, default=None):
        """Returns a given response header."""
        return self.response.headers.get(name, default)


class RESTClientObject:

    def __init__(self, configuration) -> None:

        self.initialising_keys = asyncio.Event()
        self.initialising_keys.set()
        self.configuration = configuration
        # maxsize is number of requests to host that are allowed in parallel
        maxsize = configuration.connection_pool_maxsize

        ssl_context = ssl.create_default_context(
            cafile=configuration.ssl_ca_cert
        )
        if configuration.cert_file:
            ssl_context.load_cert_chain(
                configuration.cert_file, keyfile=configuration.key_file
            )

        if not configuration.verify_ssl:
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE

        connector = aiohttp.TCPConnector(
            limit=maxsize,
            ssl=ssl_context
        )

        self.proxy = configuration.proxy
        self.proxy_headers = configuration.proxy_headers

        # https pool manager
        self.pool_manager = aiohttp.ClientSession(
            connector=connector,
            trust_env=True
        )

        retries = configuration.retries
        self.retry_client: Optional[aiohttp_retry.RetryClient]
        if retries is not None:
            self.retry_client = aiohttp_retry.RetryClient(
                client_session=self.pool_manager,
                retry_options=aiohttp_retry.ExponentialRetry(
                    attempts=retries,
                    factor=2.0,
                    start_timeout=0.1,
                    max_timeout=120.0
                )
            )
        else:
            self.retry_client = None

    async def close(self):
        await self.pool_manager.close()
        if self.retry_client is not None:
            await self.retry_client.close()

    async def request(
            self,
            method,
            url,
            headers=None,
            body=None,
            post_params=None,
            _request_timeout=None
    ):
        """Execute request

        :param method: http request method
        :param url: http request url
        :param headers: http request headers
        :param body: request json body, for `application/json`
        :param post_params: request post parameters,
                            `application/x-www-form-urlencoded`
                            and `multipart/form-data`
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        method = method.upper()
        assert method in [
            'GET',
            'HEAD',
            'DELETE',
            'POST',
            'PUT',
            'PATCH',
            'OPTIONS'
        ]

        if post_params and body:
            raise ApiValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}
        # url already contains the URL query string
        timeout = _request_timeout or 5 * 60

        if 'Content-Type' not in headers:
            headers['Content-Type'] = 'application/json'

        args = {
            "method": method,
            "url": url,
            "timeout": timeout,
            "headers": headers
        }

        if self.proxy:
            args["proxy"] = self.proxy
        if self.proxy_headers:
            args["proxy_headers"] = self.proxy_headers

        # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
        if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
            if re.search('json', headers['Content-Type'], re.IGNORECASE):
                if body is not None:
                    body = json.dumps(body)
                args["data"] = body
            elif headers['Content-Type'] == 'application/x-www-form-urlencoded':
                args["data"] = aiohttp.FormData(post_params)
            elif headers['Content-Type'] == 'multipart/form-data':
                # must del headers['Content-Type'], or the correct
                # Content-Type which generated by aiohttp
                del headers['Content-Type']
                data = aiohttp.FormData()
                for param in post_params:
                    k, v = param
                    if isinstance(v, tuple) and len(v) == 3:
                        data.add_field(
                            k,
                            value=v[1],
                            filename=v[0],
                            content_type=v[2]
                        )
                    else:
                        # Ensures that dict objects are serialized
                        if isinstance(v, dict):
                            v = json.dumps(v)
                        elif isinstance(v, int):
                            v = str(v)
                        data.add_field(k, v)
                args["data"] = data

            # Pass a `bytes` or `str` parameter directly in the body to support
            # other content types than Json when `body` argument is provided
            # in serialized form
            elif isinstance(body, str) or isinstance(body, bytes):
                args["data"] = body
            else:
                # Cannot generate the request from given parameters
                msg = """Cannot prepare a request message for provided
                         arguments. Please check that your arguments match
                         declared content type."""
                raise ApiException(status=0, reason=msg)

        pool_manager: Union[aiohttp.ClientSession, aiohttp_retry.RetryClient]
        if self.retry_client is not None and method in ALLOW_RETRY_METHODS:
            pool_manager = self.retry_client
        else:
            pool_manager = self.pool_manager

        r = await pool_manager.request(**args)

        return RESTResponse(r)

    async def initialise_keys(self):
        """logic taken from coc.py"""
        LOG.debug("Initialising keys from the developer site.")
        url = "https://developer.brawlstars.com"
        self.initialising_keys.clear()
        keys = []
        # Use context manager to automatically clean up after ourselves
        async with aiohttp.ClientSession() as session:

            body = {"email": self.configuration.username, "password": self.configuration.password}
            login_url = f"{url}/api/login"
            resp = await session.post(url=login_url, json=body)
            if resp.status == 403:
                await session.close()
                LOG.error("Invalid credentials used when attempting to log in")
                raise ApiException(http_resp=resp)

            LOG.info("Successfully logged into the developer site.")

            resp_payload = await resp.json()
            if not self.configuration.ip:
                ip = json.loads(b64decode(resp_payload["temporaryAPIToken"].split(".")[1] + "====").decode("utf-8"))[
                    "limits"][1]["cidrs"][0].split("/")[0]
            else:
                ip = self.configuration.ip
            LOG.info("Found IP address to be %s", ip)

            resp = await session.post(url=f"{url}/api/apikey/list")
            key_list = (await resp.json())["keys"]
            for key in key_list:
                LOG.debug(f"Key {key}")
                if key["name"] != self.configuration.key_names or ip not in key["cidrRanges"]:
                    continue
                keys.append(key["key"])
                if len(keys) == self.configuration.key_count:
                    break

            LOG.info("Retrieved %s valid keys from the developer site.", len(keys))

            if len(keys) < self.configuration.key_count:
                for key in keys[:]:
                    if key["name"] != self.configuration.key_names or ip in key["cidrRanges"]:
                        continue
                    LOG.info(
                        "Deleting key with the name %s and IP %s (not matching our current IP address).",
                        self.configuration.key_names, key["cidrRanges"],
                    )
                    resp = await session.post(url=f"{url}/api/apikey/revoke",
                                              json={"id": key["id"]}, headers=resp.headers)
                    if resp.status == 200:
                        keys.remove(key)

                while len(keys) < self.configuration.key_count and len(keys):
                    data = {
                        "name": self.configuration.key_names,
                        "description": "Created on {}".format(datetime.now().strftime("%c")),
                        "cidrRanges": [ip],
                        "scopes": [self.configuration.key_scopes],
                    }

                    LOG.info("Creating key with data %s.", str(data))

                    resp = await session.post(url=f"{url}/api/apikey/create", json=data)
                    key = await resp.json()

                    if resp.status != 200:
                        LOG.error(key.get("description"))
                        raise ValueError(key.get("description"))

                    keys.append(key["key"]["key"])

            if len(keys) == 10 and len(keys) < self.configuration.key_count:
                LOG.critical("%s keys were requested to be used, but a maximum of %s could be "
                             "found/made on the developer site, as it has a maximum of 10 keys per account. "
                             "Please delete some keys or lower your `key_count` level."
                             "I will use %s keys for the life of this client.",
                             self.configuration.key_count, len(keys), len(keys))

            if len(keys) == 0:
                await session.close()
                raise RuntimeError(
                    "There are {} API keys already created and none match a key_name of '{}'."
                    "Please specify a key_name kwarg, or go to '{}' to delete "
                    "unused keys.".format(len(keys), self.configuration.key_names, url)
                )

        self.configuration.keys = cycle(keys)
        self.initialising_keys.set()
        LOG.info("Successfully initialised keys for use.")
